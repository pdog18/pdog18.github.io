<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          Kotlin基础(基本类型、包、控制流、返回与跳转) - Pdog的博客 | Pdog&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://yoursite.com/2018/03/19/kotlin-base/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Pdog&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Kotlin基础(基本类型、包、控制流、返回与跳转)" title="Kotlin基础(基本类型、包、控制流、返回与跳转)">Kotlin基础(基本类型、包、控制流、返回与跳转)</a>
                        
                    </div>
                    <h1>Kotlin基础(基本类型、包、控制流、返回与跳转)</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Pdog on
                        2018-03-19
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="Kotlin-基础"><a href="#Kotlin-基础" class="headerlink" title="Kotlin 基础"></a>Kotlin 基础</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基础内容</p>
<ul>
<li>基本类型</li>
<li>包</li>
<li>控制流</li>
<li>返回与跳转</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>在Kotlin中，所有东西都是对象，在这里意义上讲我们可以在任何变量上调用成员函数和属性。一些类型可以有特殊的内部表示——例如，数字、字符和布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。</p>
<p>####数字</p>
<p>####字面常量</p>
<h4 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h4><p>数字装箱不必保留同一性（若需要可空引用类型会被装箱，装箱操作不会保留同一性）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(String : <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">var</span> b :<span class="built_in">Int</span> = a</span><br><span class="line">    <span class="keyword">var</span> c :<span class="built_in">Int</span> = a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d :<span class="built_in">Int</span>? = a</span><br><span class="line">    <span class="keyword">var</span> e :<span class="built_in">Int</span>? = a</span><br><span class="line"></span><br><span class="line">    println(a == a)     <span class="comment">//true</span></span><br><span class="line">    println(b == c)     <span class="comment">//true</span></span><br><span class="line">    println(b === c)    <span class="comment">//true</span></span><br><span class="line">    println(d === e)    <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>由于不同的表示方式，较小类型并不是较大类型的子类型。如果它们是的话，就会出现下述问题：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假想的代码，实际上并不能编译：</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="number">1</span> <span class="comment">// 一个装箱的 Int (java.lang.Integer)</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Long</span>? = a <span class="comment">// 隐式转换产生一个装箱的 Long (java.lang.Long)</span></span><br><span class="line">print(a == b) <span class="comment">// 惊！这将输出“false”鉴于 Long 的 equals() 检测其他部分也是 Long</span></span><br></pre></td></tr></table></figure>
<p>所以同一性还有相等性都会在所有地方悄无声息地失去</p>
<p>因此较小的类型不能隐式转换为较大的类型。这意味着在不进行显示转换的情况下我们不能把<code>Byte</code>型赋值给一个<code>Int</code>变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">//OK,字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>我们可以显式转换来扩宽数字</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt()	<span class="comment">//OK：显示拓宽</span></span><br></pre></td></tr></table></figure>
<p>每个数字类型支持如下的转换：</p>
<ul>
<li>toByte(): Byte</li>
<li>toShort() Short</li>
<li>toInt()</li>
<li>toLong()</li>
<li>toFloat()</li>
<li>toDouble()</li>
<li>toChar()</li>
</ul>
<p>缺乏隐式类型转换并不显著，因为类型会从上下文判断出来，而算术运算会有重载做适当装换，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="number">1</span>L + <span class="number">3</span> <span class="comment">//Long + Int =&gt; Long</span></span><br></pre></td></tr></table></figure>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>Kotlin支持数字运算的标准集，运算被定义为相应的类成员（但编译器会函数调用优化为相应的指令）。参见运算符重载。</p>
<p>对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = (<span class="number">1</span> shl <span class="number">2</span>) and <span class="number">0x000FF0000</span></span><br></pre></td></tr></table></figure>
<p> 这是完整的位运算列表（只用于<code>Int</code> 和<code>Long</code>）：</p>
<table>
<thead>
<tr>
<th>Kotlin</th>
<th>Java</th>
</tr>
</thead>
<tbody>
<tr>
<td>shl</td>
<td>&lt;&lt; 左移</td>
</tr>
<tr>
<td>shr</td>
<td>&gt;&gt; 右移</td>
</tr>
<tr>
<td>ushr</td>
<td>&gt;&gt;&gt; 无符号右移动</td>
</tr>
<tr>
<td>and</td>
<td>&amp; 与</td>
</tr>
<tr>
<td>or</td>
<td>\</td>
<td>或</td>
</tr>
<tr>
<td>xor</td>
<td>^ 异或</td>
</tr>
<tr>
<td>inv</td>
<td>~ 取反</td>
</tr>
</tbody>
</table>
<h4 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h4><ul>
<li>相等性检测：<code>a == b</code> 与<code>a != b</code></li>
<li>比较操作符：<code>a &lt; b</code> 、<code>a &gt; b</code>、<code>a &lt;= b</code>、<code>a &gt;= b</code></li>
<li>区间实例以及区间检测：<code>a..b</code> 、<code>x in a..b</code> 、<code>x !in a..b</code> </li>
</ul>
<p>当其中的操作数<code>a</code> 与<code>b</code>都是静态已知的<code>Float</code>或者<code>Double</code>或者它们对应的可空类型（声明位该类型，或者推断为该类型，或者只能类型转换的结果是该类型），两数字所形成的操作或者区间遵循IEEE 754浮点运算标准。</p>
<p>然而，为了支持泛型场景并提供全序支持，当这些操作符并非静态类型为浮点数（例如是<code>Any</code>、<code>Comparable&lt;…&gt;</code>、类型参数时），这些操作使用为<code>Float</code> 与<code>Double</code>实现的不符合标注的<code>equals</code>与<code>compareTo</code>，这会出现：</p>
<ul>
<li>认为Nan与其自身相等</li>
<li>认为Nan比包括正无穷大(<code>POSITIVE_INFINITY</code>)在内的任何其他元素都大</li>
<li>认为<code>-0.0</code>小于<code>0.0</code></li>
</ul>
<ul>
<li><p>字符</p>
<p>字符用<code>Char</code>类型表示。它们不能直接当做数字</p>
</li>
<li><p>数组</p>
<p>数组在Kotlin中使用<code>Array</code>类来表示，它定义了<code>get</code>和<code>set</code>函数（按照运算符重载约定，这会转变为<code>[]</code>和<code>size</code>属性，以及一些其他有用的成员函数）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line">  <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>:Iterator&lt;T&gt;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用库函数<code>arrayOf</code>来创建一个数组并传递元素值给它，这样<code>arrayof(1,2,3)</code>创建了array[1,2,3]。或者，库函数<code>arrayOfNulls()</code>可以用于创建一个指定大小的、所有元素都为空的数组。</p>
<p>另一个选项是用接受数组大小和一个函数参数的<code>Array</code>构造函数，用作参数的函数能够返回给顶索引的每个元素初始值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Array&lt;String&gt;初始化为["0","1","4","9","16"]</span></span><br><span class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>,&#123;i -&gt; (i * i).toString&#125;)</span><br></pre></td></tr></table></figure>
<p>如上所述，<code>[]</code>运算符代表调用成员函数<code>get()</code>和<code>set()</code>。</p>
<p>注意：与Java不同的是，Kotlin中数组是不型型变的（invariant）。这意味着Kotlin不让我们把<code>Array&lt;String&gt;</code> 赋值给<code>Array&lt;Any&gt;</code>，以防止可能的运行时失败（但是你可以使用<code>Array&lt;out Any&gt;</code>，参见类型投影）。</p>
<p>Kotlin也有无装箱开销的类来表示原生类型数组：<code>ByteArray</code>、<code>ShortArray</code>、<code>IntArray</code>等等。这些类和<code>Array</code>并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串用<code>String</code>类型表示。字符串是不可变的。字符串的元素——字符可以使用索引运算符访问：<code>s[i]</code>。可以用<code>for</code>循环迭代字符串：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> str = <span class="string">"abcd"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">      println(c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以用<code>+</code>操作符连接字符串。这也使用与连接字符串与其他类型的值，只要表达式中的第一个元素是字符串，请注意，在大多数情况下，有限使用字符串模版或原始字符串而不是字符串连接。</p>
<p>  ​</p>
<h4 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h4><p>Kotlin 有两种类型的字符串字面值：转义字符串可以有转移字符，以及原始字符串可以包含换行和任意文本。转义字符串很像Java字符串：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"Hello, world!\n"</span></span><br></pre></td></tr></table></figure>
<p>  转义采用传统的反斜杠方式。</p>
<p>  原始字符串使用三个引号（<code>””“</code>）分界符括起来，内部没有转移并钱可以包含换行和任何其他字符：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">	for(c in "foo")</span></span><br><span class="line"><span class="string">		print(c)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>  你可以通过<code>trimMargin()</code>函数去除前导空格：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="string">"""</span></span><br><span class="line"><span class="string">    |Tell me and I forget.</span></span><br><span class="line"><span class="string">    |Teach me and I remeber.</span></span><br><span class="line"><span class="string">    |Involve me and I learn.</span></span><br><span class="line"><span class="string">    |(Benjamin Franklin)</span></span><br><span class="line"><span class="string">    """</span>.trimMargin()</span><br></pre></td></tr></table></figure>
<p>  默认<code>|</code>用作边界前缀，但你可以选择其他字符并作为参数传入，比如<code>trimMargin(&quot;&gt;&quot;)</code>。</p>
<p>  ​</p>
<h4 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h4><p>  字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达<br>  式以美元符（ $ ）开头，由一个简单的名字构成:</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">    println(<span class="string">"i = <span class="variable">$i</span>"</span>) <span class="comment">// 输出“i = 10”</span></span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  或者用花括号括起来的任意表达式:</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"abc"</span></span><br><span class="line">    println(<span class="string">"<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span>) <span class="comment">// 输出“abc.length is 3”</span></span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  原始字符串和转义字符串内部都支持模板。 如果你需要在原始字符串中表示字面值 $ 字符<br>  （它不支持反斜杠转义），你可以用下列语法：</p>
  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> price = <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>  ​</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>源文件通常以包声明为开头，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goo</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure>
<p>源文件所有内容（无论是类还是函数）都包含声明的包内。所以上例中<code>baz()</code>的全名是<code>foo.bar.baz</code>、<code>Goo</code>的全名是<code>foo.bar.Goo</code></p>
<p>如果没有指明包，该文件的内容属于无名字的默认包。</p>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>如果出现名字冲突，可以使用<code>as</code> 关键字在本地重命名冲突项来消歧义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo.Bar 	<span class="comment">//Bar可访问</span></span><br><span class="line"><span class="keyword">import</span> bar.Bar <span class="keyword">as</span> bBar <span class="comment">//bBar 代表"bar.Bar"</span></span><br></pre></td></tr></table></figure>
<p>关键字<code>import</code>并不仅限于导入类；也可用它来导入其他声明：</p>
<ul>
<li>顶层函数及属性；</li>
<li>在对象声明中声明的函数和属性；</li>
<li>枚举常量。</li>
</ul>
<p>与Java不同，Kotlin没有单独的import static 语法；所有这些声明都用import 关键字导入。</p>
<h2 id="控制流-：-if、when、for、while"><a href="#控制流-：-if、when、for、while" class="headerlink" title="控制流 ： if、when、for、while"></a>控制流 ： if、when、for、while</h2><h3 id="If表达式"><a href="#If表达式" class="headerlink" title="If表达式"></a>If表达式</h3><p>在Kotlin中，<code>if</code>是一个表达式，即它会返回一个值。因此就不需要三元运算符，因为普通的<code>if</code>就能胜任这个角色。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统用法</span></span><br><span class="line"><span class="keyword">var</span> max = a</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) max = b</span><br><span class="line"></span><br><span class="line"><span class="comment">//With else</span></span><br><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">  max = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  max = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为表达式</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<p><code>if</code>的分支可以是代码块，最后的表达式作为该块的值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">  print(<span class="string">"Choose a"</span>)</span><br><span class="line">  a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  print(<span class="string">"Choose b"</span>)</span><br><span class="line">  b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用<code>if</code>作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有<code>else</code>分支</p>
<h3 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h3><p><code>when</code>取代了类C语言的<code>switch</code>操作符。</p>
<p>when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。 when 既可以被当<br>做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个<br>表达式的值，如果当做语句使用， 则忽略个别分支的值。（像 if 一样，每一个分支可以是<br>一个代码块，它的值是块中最后的表达式的值。）</p>
<p>如果其他分支都不满足条件将会求值 else 分支。 如果 when 作为一个表达式使用，则必须<br>有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了(密封类)。</p>
<p>如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用任意表达式（而不只是常量）作为分支条件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  parseInt(s) -&gt; print(<span class="string">"s encodes x"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以检测一个值在（ in ）或者不在（ !in ）一个区间或者集合中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">  <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">  <span class="keyword">in</span> validNumbers -&gt; print(<span class="string">"x is valid"</span>)</span><br><span class="line">  !<span class="keyword">in</span> <span class="number">10.</span><span class="number">.20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种可能性是检测一个值是（ is ）或者不是（ !is ）一个特定类型的值。注意： 由于智<br>能转换，你可以访问该类型的方法和属性而无需任何额外的检测。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasPrefix</span><span class="params">(x: <span class="type">Any</span>)</span></span> = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">  <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when 也可以用来取代 if - else if 链。 如果不提供参数，所有的分支条件都是简单的布<br>尔表达式，而当一个分支的条件为真时则执行该分支：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h3><p>如果你想通过索引遍历一个数组或者一个list，你可以这么做：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> array = arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    	println(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者你可以用库函数<code>withIndex</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> array = arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">   		 println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h3>

                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/03/20/kotlin-basic-grammar/" data-toggle="tooltip" data-placement="top" title="Kotlin基础语法">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/03/17/kotlin/" data-toggle="tooltip" data-placement="top" title="Kotlin">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Kotlin基础(基本类型、包、控制流、返回与跳转)" title="Kotlin基础(基本类型、包、控制流、返回与跳转)">Kotlin基础(基本类型、包、控制流、返回与跳转)</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://blog.kaijun.rocks" target="_blank">Kaijun&#39;s Blog</a></li>
                    
                        <li><a href="http://huangxuan.me" target="_blank">Hux Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                        <li><a href="#" target="_blank">Bar</a></li>
                    
                        <li><a href="#" target="_blank">Example Friends</a></li>
                    
                        <li><a href="#" target="_blank">It helps SEO</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hexo-theme-huxblog";
    var disqus_identifier = "http://yoursite.com/2018/03/19/kotlin-base/";
    var disqus_url = "http://yoursite.com/2018/03/19/kotlin-base/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/pdog18">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Pdog&#39;s Blog 2018 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-49627206-1';
    var _gaDomain = 'pdog18.cn';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '4cc1f2d8f3067386cc5cdb626a202900';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
